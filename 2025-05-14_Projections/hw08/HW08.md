# [08] Проекции и материализованные представления

> *При создании таблицы и подготовке тестовых данных использовалась языковая модель [DeepSeek](https://chat.deepseek.com/).*

## Таблица

Поскольку далее мы будем экспериментировать с агрегацией данных по **product_id**, то первый уровень сортировки в исходной таблице сделаем по другому полю (**sale_date**):

```sql
CREATE OR REPLACE TABLE sales
(
    `id` UInt32,
    `product_id` UInt32,
    `quantity` UInt32,
    `price` Float32,
    `sale_date` DateTime
)
ENGINE = MergeTree
ORDER BY (sale_date, product_id)

0 rows in set. Elapsed: 0.016 sec.
```

Заполняем таблицу тестовыми данными.

```sql
INSERT INTO sales (id, product_id, quantity, price, sale_date) VALUES
    (1, 101, 2, 15.99, '2023-01-15 10:30:00'),
    (2, 102, 1, 29.99, '2023-01-15 11:15:00'),
    (3, 103, 5, 9.99, '2023-01-16 09:45:00'),
    (4, 101, 3, 15.99, '2023-01-17 14:20:00'),
    (5, 104, 2, 49.99, '2023-01-18 16:30:00'),
    (6, 102, 1, 29.99, '2023-01-19 12:10:00'),
    (7, 105, 4, 19.99, '2023-01-20 10:45:00'),
    (8, 103, 2, 9.99, '2023-01-20 15:30:00'),
    (9, 101, 1, 15.99, '2023-01-21 11:20:00'),
    (10, 104, 1, 49.99, '2023-01-22 13:40:00'),
    (11, 106, 3, 24.99, '2023-01-23 10:15:00'),
    (12, 102, 2, 29.99, '2023-01-24 14:50:00'),
    (13, 105, 1, 19.99, '2023-01-25 09:30:00'),
    (14, 101, 4, 15.99, '2023-01-26 16:20:00'),
    (15, 103, 3, 9.99, '2023-01-27 12:45:00');

15 rows in set. Elapsed: 0.021 sec.
```

<details>

<summary>Добавляем дополнительные тестовые данные.</summary>

```sql
INSERT INTO sales (id, product_id, quantity, price, sale_date) VALUES
    (16, 107, 2, 39.99, '2023-02-01 10:25:00'),
    (17, 108, 1, 89.99, '2023-02-02 14:30:00'),
    (18, 109, 3, 12.49, '2023-02-03 11:15:00'),
    (19, 110, 2, 19.99, '2023-02-04 16:40:00'),
    (20, 101, 1, 15.99, '2023-02-05 09:20:00'),
    (21, 102, 4, 29.99, '2023-02-06 13:10:00'),
    (22, 103, 2, 9.99, '2023-02-07 10:45:00'),
    (23, 104, 1, 49.99, '2023-02-08 15:30:00'),
    (24, 105, 3, 19.99, '2023-02-09 12:20:00'),
    (25, 106, 2, 24.99, '2023-02-10 14:15:00'),
    (26, 107, 1, 39.99, '2023-02-11 11:30:00'),
    (27, 108, 2, 89.99, '2023-02-12 16:45:00'),
    (28, 109, 4, 12.49, '2023-02-13 10:10:00'),
    (29, 110, 1, 19.99, '2023-02-14 13:25:00'),
    (30, 101, 2, 15.99, '2023-02-15 09:40:00'),
    (31, 102, 1, 29.99, '2023-03-01 14:20:00'),
    (32, 103, 3, 9.99, '2023-03-02 11:35:00'),
    (33, 104, 2, 49.99, '2023-03-03 16:50:00'),
    (34, 105, 1, 19.99, '2023-03-04 10:05:00'),
    (35, 106, 2, 24.99, '2023-03-05 13:15:00'),
    (36, 107, 3, 39.99, '2023-03-06 15:25:00'),
    (37, 108, 1, 89.99, '2023-03-07 09:30:00'),
    (38, 109, 2, 12.49, '2023-03-08 12:40:00'),
    (39, 110, 4, 19.99, '2023-03-09 14:55:00'),
    (40, 101, 1, 15.99, '2023-03-10 11:10:00'),
    (41, 102, 2, 29.99, '2023-04-11 16:20:00'),
    (42, 103, 1, 9.99, '2023-04-12 10:35:00'),
    (43, 104, 3, 49.99, '2023-04-13 13:45:00'),
    (44, 105, 2, 19.99, '2023-04-14 15:50:00'),
    (45, 106, 1, 24.99, '2023-04-15 09:05:00'),
    (46, 107, 2, 39.99, '2023-05-16 12:15:00'),
    (47, 108, 1, 89.99, '2023-05-17 14:25:00'),
    (48, 109, 3, 12.49, '2023-05-18 16:35:00'),
    (49, 110, 2, 19.99, '2023-05-19 10:45:00'),
    (50, 101, 4, 15.99, '2023-05-20 13:55:00'),
    (51, 102, 1, 27.99, '2023-01-15 10:00:00'),
    (52, 102, 2, 25.99, '2023-06-10 11:00:00'),
    (53, 103, 5, 8.99, '2023-07-05 09:30:00'),
    (54, 104, 1, 45.00, '2023-08-12 14:20:00'),
    (55, 105, 3, 17.50, '2023-09-18 16:10:00');
```

</details>

На текущий момент в таблице *sales* всего 55 записей:

```sql
SELECT count()
FROM sales
FORMAT TSV

55
```

## Проекция

Агрегируем данные по **product_id** и считаем общее число продаж, количество проданных единиц и суммарную стоимость для каждого продукта.

> Тем самым также проверяем разные агрегатные функции, как и предлагается в задании со \*

```sql
ALTER TABLE sales
    (ADD PROJECTION product_sales_projection
    (
        SELECT
            product_id,
            sum(quantity) AS total_quantity,
            sum(quantity * price) AS total_revenue,
            count() AS total_sales
        GROUP BY product_id
    ))

0 rows in set. Elapsed: 0.016 sec.
```

На данном этапе созданная проекция не может использоваться для уже существующих в таблице данных, потому что она не была материализована. Это можно подтвердить проверив план запроса через [`EXPLAIN`](https://clickhouse.com/docs/sql-reference/statements/explain):

```sql
EXPLAIN
SELECT
    product_id,
    sum(quantity) AS total_quantity,
    sum(quantity * price) AS total_revenue,
    count() AS total_sales
FROM sales
GROUP BY product_id

   ┌─explain────────────────────────────────────────────────────────────────────────┐
1. │ Expression ((Project names + Projection))                                      │
2. │   Aggregating                                                                  │
3. │     Expression ((Before GROUP BY + Change column names to column identifiers)) │
4. │       ReadFromMergeTree (default.sales)                                        │
   └────────────────────────────────────────────────────────────────────────────────┘

4 rows in set. Elapsed: 0.010 sec.
```

Выполним материализацию проекции для уже существующих данных.

```sql
ALTER TABLE sales
    (MATERIALIZE PROJECTION product_sales_projection)

0 rows in set. Elapsed: 0.016 sec.
```

План запроса ожидаемо изменился. Теперь запрос идёт через проекцию:

```sql
EXPLAIN
SELECT
    product_id,
    sum(quantity) AS total_quantity,
    sum(quantity * price) AS total_revenue,
    count() AS total_sales
FROM sales
GROUP BY product_id

   ┌─explain────────────────────────────────────────────┐
1. │ Expression ((Project names + Projection))          │
2. │   Aggregating                                      │
3. │     Expression                                     │
4. │       ReadFromMergeTree (product_sales_projection) │
   └────────────────────────────────────────────────────┘

4 rows in set. Elapsed: 0.007 sec.
```

Результат самого запроса можно посмотреть ниже в разделе ["Запрос через проекцию"](#запрос-через-проекцию).

## Материализованное представление

### Создание таблицы для агрегированных данных

Создадим таблицу для хранения агрегированных данных материализованного представления:

```sql
CREATE OR REPLACE TABLE sales_aggregated
(
    `product_id` UInt32,
    `total_quantity` AggregateFunction(sum, UInt32),
    `total_revenue` AggregateFunction(sum, Float64),
    `total_sales` AggregateFunction(count, UInt32)
)
ENGINE = AggregatingMergeTree
ORDER BY product_id

0 rows in set. Elapsed: 0.045 sec.
```

### Создание материализованного представления

```sql
DROP VIEW IF EXISTS sales_mv

0 rows in set. Elapsed: 0.004 sec.


CREATE MATERIALIZED VIEW sales_mv TO sales_aggregated
AS SELECT
    product_id,
    sumState(quantity) AS total_quantity,
    sumState(quantity * price) AS total_revenue,
    countState() AS total_sales
FROM sales
GROUP BY product_id

0 rows in set. Elapsed: 0.021 sec.
```

### Добавление данных в материализованное представление

Вставка агрегированных данных из существующих записей:

```sql
INSERT INTO sales_aggregated SELECT
    product_id,
    sumState(quantity) AS total_quantity,
    sumState(quantity * price) AS total_revenue,
    countState() AS total_sales
FROM sales
GROUP BY product_id

0 rows in set. Elapsed: 0.013 sec.
```

Результат запроса агрегированных данных через материализованное представление можно увидеть ниже в разделе ["Запрос через материализованное представление"](#запрос-через-материализованное-представление).

## Запросы к данным

Чтобы проверить, что как проекция, так и материализованное представление работают для вновь поступающих данных, добавим ещё некоторое количество тестовых данных, доведя общее число записей в таблице с исходными данными *sales* до 100.

> Тем самым также исследуем, как изменения в основной таблице влияют на проекции и материализованные представления, как и предлагается в задании со \*

<details>

<summary>Добавляем дополнительные тестовые данные.</summary>

```sql
INSERT INTO sales (id, product_id, quantity, price, sale_date) VALUES
    (56, 101, 2, 16.50, '2023-10-01 09:15:00'),
    (57, 102, 1, 30.50, '2023-10-02 10:30:00'),
    (58, 103, 3, 10.25, '2023-10-03 11:45:00'),
    (59, 104, 1, 50.00, '2023-10-04 12:00:00'),
    (60, 105, 2, 20.75, '2023-10-05 13:20:00'),
    (61, 106, 1, 25.99, '2023-10-06 14:35:00'),
    (62, 107, 3, 40.25, '2023-10-07 15:50:00'),
    (63, 108, 2, 90.00, '2023-10-08 16:05:00'),
    (64, 109, 1, 13.00, '2023-10-09 09:30:00'),
    (65, 110, 4, 20.50, '2023-10-10 10:45:00'),
    (66, 101, 1, 16.50, '2023-10-11 11:00:00'),
    (67, 102, 2, 30.50, '2023-10-12 12:15:00'),
    (68, 103, 1, 10.25, '2023-10-13 13:30:00'),
    (69, 104, 3, 50.00, '2023-10-14 14:45:00'),
    (70, 105, 2, 20.75, '2023-10-15 15:00:00'),
    (71, 106, 1, 25.99, '2023-10-16 16:15:00'),
    (72, 107, 2, 40.25, '2023-10-17 09:20:00'),
    (73, 108, 1, 90.00, '2023-10-18 10:35:00'),
    (74, 109, 3, 13.00, '2023-10-19 11:50:00'),
    (75, 110, 2, 20.50, '2023-10-20 12:05:00'),
    (76, 101, 1, 16.50, '2023-10-21 13:20:00'),
    (77, 102, 4, 30.50, '2023-10-22 14:35:00'),
    (78, 103, 2, 10.25, '2023-10-23 15:50:00'),
    (79, 104, 1, 50.00, '2023-10-24 16:05:00'),
    (80, 105, 3, 20.75, '2023-10-25 09:10:00'),
    (81, 106, 2, 25.99, '2023-10-26 10:25:00'),
    (82, 107, 1, 40.25, '2023-10-27 11:40:00'),
    (83, 108, 2, 90.00, '2023-10-28 12:55:00'),
    (84, 109, 1, 13.00, '2023-10-29 13:10:00'),
    (85, 110, 3, 20.50, '2023-10-30 14:25:00'),
    (86, 101, 2, 16.50, '2023-11-01 15:40:00'),
    (87, 102, 1, 30.50, '2023-11-02 16:55:00'),
    (88, 103, 4, 10.25, '2023-11-03 09:05:00'),
    (89, 104, 2, 50.00, '2023-11-04 10:20:00'),
    (90, 105, 1, 20.75, '2023-11-05 11:35:00'),
    (91, 106, 3, 25.99, '2023-11-06 12:50:00'),
    (92, 107, 2, 40.25, '2023-11-07 13:05:00'),
    (93, 108, 1, 90.00, '2023-11-08 14:20:00'),
    (94, 109, 2, 13.00, '2023-11-09 15:35:00'),
    (95, 110, 1, 20.50, '2023-11-10 16:50:00'),
    (96, 101, 3, 16.50, '2023-11-11 09:15:00'),
    (97, 102, 2, 30.50, '2023-11-12 10:30:00'),
    (98, 103, 1, 10.25, '2023-11-13 11:45:00'),
    (99, 104, 4, 50.00, '2023-11-14 12:00:00'),
    (100, 105, 2, 20.75, '2023-11-15 13:15:00');
```

</details>

### Запрос через проекцию

```sql
SELECT
    product_id,
    sum(quantity) AS total_quantity,
    round(sum(quantity * price), 2) AS total_revenue,
    count() AS total_sales
FROM sales
GROUP BY product_id
ORDER BY product_id ASC

    ┌─product_id─┬─total_quantity─┬─total_revenue─┬─total_sales─┐
 1. │        101 │             27 │        436.32 │          13 │
 2. │        102 │             24 │        714.86 │          13 │
 3. │        103 │             32 │        317.54 │          12 │
 4. │        104 │             21 │       1044.91 │          11 │
 5. │        105 │             24 │        479.89 │          11 │
 6. │        106 │             15 │        381.85 │           8 │
 7. │        107 │             16 │        641.92 │           8 │
 8. │        108 │             11 │        989.95 │           8 │
 9. │        109 │             19 │        240.88 │           8 │
10. │        110 │             19 │        384.91 │           8 │
    └────────────┴────────────────┴───────────────┴─────────────┘

10 rows in set. Elapsed: 0.015 sec.
```

### Запрос через материализованное представление

```sql
SELECT
    product_id,
    sumMerge(total_quantity) AS total_quantity,
    round(sumMerge(total_revenue), 2) AS total_revenue,
    countMerge(total_sales) AS total_sales
FROM sales_mv
GROUP BY product_id
ORDER BY product_id ASC

    ┌─product_id─┬─total_quantity─┬─total_revenue─┬─total_sales─┐
 1. │        101 │             27 │        436.32 │          13 │
 2. │        102 │             24 │        714.86 │          13 │
 3. │        103 │             32 │        317.54 │          12 │
 4. │        104 │             21 │       1044.91 │          11 │
 5. │        105 │             24 │        479.89 │          11 │
 6. │        106 │             15 │        381.85 │           8 │
 7. │        107 │             16 │        641.92 │           8 │
 8. │        108 │             11 │        989.95 │           8 │
 9. │        109 │             19 │        240.88 │           8 │
10. │        110 │             19 │        384.91 │           8 │
    └────────────┴────────────────┴───────────────┴─────────────┘

10 rows in set. Elapsed: 0.016 sec.
```

Как можно видеть, оба запроса возвращают идентичный результат.

## Сравнение производительности

### Увеличиваем объём данных в таблице

Простое заполнение таблицы случайными тестовыми данными через [`generateRandom`](https://clickhouse.com/docs/sql-reference/table-functions/generate) в данном случае не подходит, потому что мы хотели бы, чтобы количество продуктов (уникальных **product_id**) было относительно небольшим. Кроме того, цена продуктов одного типа (с совпадающим **product_id**) должна быть одинаковой.

Поэтому моя идея здесь была в том, чтобы многократно продублировать уже существующие 100 записей в таблице, доведя общее число записей до 20 000 000 (произвольное большое число). Возможно, способ, которым я решил эту задачу, неоптимальный, но мне в голову пришла идея сделать это через `JOIN`:

```sql
INSERT INTO sales SELECT s.*
FROM
(
    SELECT number + 1 AS n
    FROM numbers(20000000)
) AS n
LEFT JOIN
(
    SELECT *
    FROM sales
) AS s ON ((n.n % 100) + 1) = s.id

0 rows in set. Elapsed: 11.828 sec. Processed 60.00 million rows, 800.00 MB (5.07 million rows/s., 67.64 MB/s.)
Peak memory usage: 102.85 MiB.


SELECT count()
FROM sales

   ┌──count()─┐
1. │ 20000100 │ -- 20.00 million
   └──────────┘

1 row in set. Elapsed: 0.004 sec.
```

### Бенчмарк запроса через проекцию

Повторим такой же запрос через проекцию, как [выше](#запрос-через-проекцию).

```sql
SELECT
    product_id,
    sum(quantity) AS total_quantity,
    round(sum(quantity * price), 2) AS total_revenue,
    count() AS total_sales
FROM sales
GROUP BY product_id
ORDER BY product_id ASC

    ┌─product_id─┬─total_quantity─┬─total_revenue─┬─total_sales─┐
 1. │        101 │        5400027 │    87264435.5 │     2600013 │
 2. │        102 │        4800024 │  142972714.22 │     2600013 │
 3. │        103 │        6400032 │   63508316.58 │     2400012 │
 4. │        104 │        4200021 │  208983047.93 │     2200011 │
 5. │        105 │        4800024 │   95978479.39 │     2200011 │
 6. │        106 │        3000015 │   76370381.16 │     1600008 │
 7. │        107 │        3200016 │  128384644.61 │     1600008 │
 8. │        108 │        2200011 │  197990987.81 │     1600008 │
 9. │        109 │        3800019 │   48176240.33 │     1600008 │
10. │        110 │        3800019 │    76982384.5 │     1600008 │
    └────────────┴────────────────┴───────────────┴─────────────┘

10 rows in set. Elapsed: 0.020 sec.
```

Но теперь с помощью [`clickhouse-benchmark`](https://clickhouse.com/docs/operations/utilities/clickhouse-benchmark):

```shell
root@3e16fa9ca9d8:/# cat projection.sql | fold -w 100 -s
SELECT product_id, sum(quantity) AS total_quantity, round(sum(quantity * price), 2) AS
total_revenue, count() AS total_sales FROM sales GROUP BY product_id ORDER BY product_id ASC


root@3e16fa9ca9d8:/# clickhouse-benchmark --password "${DEFAULT_PASSWORD}" -i 10 < projection.sql
Loaded 1 queries.

Queries executed: 10.

localhost:9000, queries: 10, QPS: 32.556, RPS: 325.564, MiB/s: 0.016, result RPS: 325.564, result MiB/s: 0.009.

0%              0.011 sec.
10%             0.012 sec.
20%             0.013 sec.
30%             0.013 sec.
40%             0.013 sec.
50%             0.014 sec.
60%             0.014 sec.
70%             0.014 sec.
80%             0.015 sec.
90%             0.017 sec.
95%             0.017 sec.
99%             0.017 sec.
99.9%           0.017 sec.
99.99%          0.017 sec.
```

### Бенчмарк запроса через материализованное представление

Повторим такой же запрос через материализованное представление, как [выше](#запрос-через-материализованное-представление).

```sql
SELECT
    product_id,
    sumMerge(total_quantity) AS total_quantity,
    round(sumMerge(total_revenue), 2) AS total_revenue,
    countMerge(total_sales) AS total_sales
FROM sales_mv
GROUP BY product_id
ORDER BY product_id ASC

    ┌─product_id─┬─total_quantity─┬─total_revenue─┬─total_sales─┐
 1. │        101 │        5400027 │    87264435.5 │     2600013 │
 2. │        102 │        4800024 │  142972714.22 │     2600013 │
 3. │        103 │        6400032 │   63508316.58 │     2400012 │
 4. │        104 │        4200021 │  208983047.93 │     2200011 │
 5. │        105 │        4800024 │   95978479.39 │     2200011 │
 6. │        106 │        3000015 │   76370381.16 │     1600008 │
 7. │        107 │        3200016 │  128384644.61 │     1600008 │
 8. │        108 │        2200011 │  197990987.81 │     1600008 │
 9. │        109 │        3800019 │   48176240.33 │     1600008 │
10. │        110 │        3800019 │    76982384.5 │     1600008 │
    └────────────┴────────────────┴───────────────┴─────────────┘

10 rows in set. Elapsed: 0.019 sec.
```

Но теперь с помощью [`clickhouse-benchmark`](https://clickhouse.com/docs/operations/utilities/clickhouse-benchmark):

```shell
root@3e16fa9ca9d8:/# cat matview.sql | fold -w 100 -s
SELECT product_id, sumMerge(total_quantity) AS total_quantity, round(sumMerge(total_revenue), 2) AS
total_revenue, countMerge(total_sales) AS total_sales FROM sales_mv GROUP BY product_id ORDER BY
product_id ASC


root@3e16fa9ca9d8:/# clickhouse-benchmark --password "${DEFAULT_PASSWORD}" -i 10 < matview.sql
Loaded 1 queries.

Queries executed: 10.

localhost:9000, queries: 10, QPS: 30.334, RPS: 1092.019, MiB/s: 0.054, result RPS: 303.339, result MiB/s: 0.008.

0%              0.013 sec.
10%             0.014 sec.
20%             0.015 sec.
30%             0.016 sec.
40%             0.016 sec.
50%             0.016 sec.
60%             0.016 sec.
70%             0.017 sec.
80%             0.017 sec.
90%             0.018 sec.
95%             0.018 sec.
99%             0.018 sec.
99.9%           0.018 sec.
99.99%          0.018 sec.
```

### Бенчмарк прямого запроса к таблице (без проекции)

Для сравнения удалим проекцию и попробуем аналогичный запрос с агрегацией по &laquo;сырым&raquo; данным.

```sql
ALTER TABLE sales
    (DROP PROJECTION product_sales_projection)

0 rows in set. Elapsed: 0.034 sec.
```

```shell
root@3e16fa9ca9d8:/# cat projection.sql | fold -w 100 -s
SELECT product_id, sum(quantity) AS total_quantity, round(sum(quantity * price), 2) AS
total_revenue, count() AS total_sales FROM sales GROUP BY product_id ORDER BY product_id ASC


root@3e16fa9ca9d8:/# clickhouse-benchmark --password "${DEFAULT_PASSWORD}" -i 10 < projection.sql
Loaded 1 queries.

. . . . .

Queries executed: 10.

localhost:9000, queries: 10, QPS: 4.207, RPS: 84132070.240, MiB/s: 962.815, result RPS: 42.066, result MiB/s: 0.001.

0%              0.199 sec.
10%             0.202 sec.
20%             0.208 sec.
30%             0.209 sec.
40%             0.217 sec.
50%             0.226 sec.
60%             0.226 sec.
70%             0.229 sec.
80%             0.241 sec.
90%             0.243 sec.
95%             0.266 sec.
99%             0.266 sec.
99.9%           0.266 sec.
99.99%          0.266 sec.
```

### Вывод

Для аналогичных запросов с агрегацией, на проекции и на материализованном представлении скорость ожидаемо получается практически одинаковой. И так же ожидаемым образом она на порядок выше прямого запроса к таблице с группировкой по &laquo;сырым&raquo; данным.
