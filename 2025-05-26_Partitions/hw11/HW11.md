# [11] Мутации данных и манипуляции с партициями

```sql
SELECT
    version(),
    toDate(now('Europe/Moscow'))
FORMAT tsv

25.4.2.31       2025-06-05
```

> *Для создания таблицы и заполнения её тестовыми данными    использовалась языковая модель [DeepSeek](https://chat.deepseek.com/).*

## Создание таблицы

```sql
CREATE OR REPLACE TABLE user_activity
(
    `user_id` UInt32,
    `activity_type` String,
    `activity_date` DateTime
)
ENGINE = MergeTree
PARTITION BY toYYYYMM(activity_date)
ORDER BY (activity_date, user_id)

0 rows in set. Elapsed: 0.036 sec.
```

## Заполнение таблицы

Используем различные *user_id*, *activity_type* и *activity_date*.

```sql
INSERT INTO user_activity (user_id, activity_type, activity_date)
SELECT
    (number % 50) + 100  AS user_id,
    CASE
        WHEN number % 3 = 0 THEN 'login'
        WHEN number % 3 = 1 THEN 'purchase'
        ELSE 'logout'
    END AS activity_type,
    toDateTime('2025-03-01 00:00:00') + number * 3600 * 12  AS activity_date
FROM numbers(180);

0 rows in set. Elapsed: 0.025 sec.
```

Проверим созданные партиции:

```sql
SELECT
    `table`,
    partition,
    name,
    rows,
    active
FROM system.parts
WHERE `table` = 'user_activity'

   ┌─table─────────┬─partition─┬─name─────────┬─rows─┬─active─┐
1. │ user_activity │ 202503    │ 202503_1_1_0 │   62 │      1 │
2. │ user_activity │ 202504    │ 202504_2_2_0 │   60 │      1 │
3. │ user_activity │ 202505    │ 202505_3_3_0 │   58 │      1 │
   └───────────────┴───────────┴──────────────┴──────┴────────┘

3 rows in set. Elapsed: 0.002 sec.
```

Проверим данные в таблице:

```sql
SELECT
    mon,
    activity_type,
    count() AS cnt
FROM user_activity
GROUP BY
    toYYYYMM(activity_date) AS mon,
    activity_type
ORDER BY
    mon ASC,
    activity_type ASC

   ┌────mon─┬─activity_type─┬─cnt─┐
1. │ 202503 │ login         │  21 │
2. │ 202503 │ logout        │  20 │
3. │ 202503 │ purchase      │  21 │
4. │ 202504 │ login         │  20 │
5. │ 202504 │ logout        │  20 │
6. │ 202504 │ purchase      │  20 │
7. │ 202505 │ login         │  19 │
8. │ 202505 │ logout        │  20 │
9. │ 202505 │ purchase      │  19 │
   └────────┴───────────────┴─────┘

9 rows in set. Elapsed: 0.005 sec.
```

## Выполнение мутаций

Выполним мутацию для изменения типа активности у пользователя(-ей).

```sql
ALTER TABLE user_activity
    (UPDATE activity_type = 'auth' WHERE activity_type = 'login')

0 rows in set. Elapsed: 0.008 sec.
```

## Проверка результатов

Проверим изменения в таблице *user_activity*. Убедимся, что тип активности у пользователей изменился:

```sql
SELECT
    mon,
    activity_type,
    count() AS cnt
FROM user_activity
GROUP BY
    toYYYYMM(activity_date) AS mon,
    activity_type
ORDER BY
    mon ASC,
    activity_type ASC

   ┌────mon─┬─activity_type─┬─cnt─┐
1. │ 202503 │ auth          │  21 │
2. │ 202503 │ logout        │  20 │
3. │ 202503 │ purchase      │  21 │
4. │ 202504 │ auth          │  20 │
5. │ 202504 │ logout        │  20 │
6. │ 202504 │ purchase      │  20 │
7. │ 202505 │ auth          │  19 │
8. │ 202505 │ logout        │  20 │
9. │ 202505 │ purchase      │  19 │
   └────────┴───────────────┴─────┘

9 rows in set. Elapsed: 0.022 sec.
```

Отследим мутации через системную таблицу:

```sql
SELECT
    `table`,
    mutation_id,
    command,
    is_done
FROM system.mutations
WHERE `table` = 'user_activity'
FORMAT vertical

Row 1:
──────
table:       user_activity
mutation_id: mutation_4.txt
command:     (UPDATE activity_type = 'auth' WHERE activity_type = 'login')
is_done:     1

1 row in set. Elapsed: 0.003 sec.
```

## Манипуляции с партициями

Удалим партицию `202504`.

```sql
ALTER TABLE user_activity
    (DROP PARTITION '202504')

0 rows in set. Elapsed: 0.005 sec.
```

## Проверка состояния таблицы

Убедимся, что данные за указанный месяц были удалены:

```sql
SELECT
    mon,
    activity_type,
    count() AS cnt
FROM user_activity
GROUP BY
    toYYYYMM(activity_date) AS mon,
    activity_type
ORDER BY
    mon ASC,
    activity_type ASC

   ┌────mon─┬─activity_type─┬─cnt─┐
1. │ 202503 │ auth          │  21 │
2. │ 202503 │ logout        │  20 │
3. │ 202503 │ purchase      │  21 │
4. │ 202505 │ auth          │  19 │
5. │ 202505 │ logout        │  20 │
6. │ 202505 │ purchase      │  19 │
   └────────┴───────────────┴─────┘

6 rows in set. Elapsed: 0.008 sec.
```

Проверим состояние партиций:

```sql
SELECT
    `table`,
    partition,
    name,
    rows,
    active
FROM system.parts
WHERE `table` = 'user_activity'

   ┌─table─────────┬─partition─┬─name───────────┬─rows─┬─active─┐
1. │ user_activity │ 202503    │ 202503_1_1_0_4 │   62 │      1 │
2. │ user_activity │ 202504    │ 202504_2_2_1_4 │    0 │      0 │
3. │ user_activity │ 202505    │ 202505_3_3_0_4 │   58 │      1 │
   └───────────────┴───────────┴────────────────┴──────┴────────┘

3 rows in set. Elapsed: 0.004 sec.
```

Как можно видеть, партиция `202504` действительно была удалена.

## Дополнительные задания

### Создание новой партиции

Создадим временную таблицу.

```sql
CREATE OR REPLACE TABLE user_activity_staging
(
    `user_id` UInt32,
    `activity_type` String,
    `activity_date` DateTime
)
ENGINE = MergeTree
PARTITION BY toYYYYMM(activity_date)
ORDER BY (activity_date, user_id)

0 rows in set. Elapsed: 0.020 sec.
```

Заполним данными партицию `202504` в созданной таблице.

```sql
INSERT INTO user_activity_staging (user_id, activity_type, activity_date)
SELECT
    (number % 50) + 100  AS user_id,
    CASE
        WHEN number % 3 = 0 THEN 'auth'
        WHEN number % 3 = 1 THEN 'purchase'
        ELSE 'logout'
    END AS activity_type,
    toDateTime('2025-04-01 00:00:00') + number * 3600 * 12  AS activity_date
FROM numbers(30);

0 rows in set. Elapsed: 0.005 sec.
```

Проверим партиции через системную таблицу:

```sql
SELECT
    `table`,
    partition,
    name,
    rows,
    active
FROM system.parts
WHERE (`table` LIKE 'user_activity%') AND active

   ┌─table─────────────────┬─partition─┬─name───────────┬─rows─┬─active─┐
1. │ user_activity         │ 202503    │ 202503_1_1_0_4 │   62 │      1 │
2. │ user_activity         │ 202505    │ 202505_3_3_0_4 │   58 │      1 │
3. │ user_activity_staging │ 202504    │ 202504_1_1_0   │   30 │      1 │
   └───────────────────────┴───────────┴────────────────┴──────┴────────┘

3 rows in set. Elapsed: 0.007 sec.
```

Переместим партицию из временной таблицы в основную.

```sql
ALTER TABLE user_activity_staging
    (MOVE PARTITION '202504' TO TABLE user_activity)

0 rows in set. Elapsed: 0.004 sec.
```

Опять проверяем партиции:

```sql
SELECT
    `table`,
    partition,
    name,
    rows,
    active
FROM system.parts
WHERE (`table` LIKE 'user_activity%') AND active

   ┌─table─────────┬─partition─┬─name───────────┬─rows─┬─active─┐
1. │ user_activity │ 202503    │ 202503_1_1_0_4 │   62 │      1 │
2. │ user_activity │ 202504    │ 202504_5_5_0   │   30 │      1 │
3. │ user_activity │ 202505    │ 202505_3_3_0_4 │   58 │      1 │
   └───────────────┴───────────┴────────────────┴──────┴────────┘

3 rows in set. Elapsed: 0.007 sec.
```

Наконец, проверим данные в основной таблице, повторив тот же самый запрос, что и раньше:

```sql
SELECT
    mon,
    activity_type,
    count() AS cnt
FROM user_activity
GROUP BY
    toYYYYMM(activity_date) AS mon,
    activity_type
ORDER BY
    mon ASC,
    activity_type ASC

   ┌────mon─┬─activity_type─┬─cnt─┐
1. │ 202503 │ auth          │  21 │
2. │ 202503 │ logout        │  20 │
3. │ 202503 │ purchase      │  21 │
4. │ 202504 │ auth          │  10 │
5. │ 202504 │ logout        │  10 │
6. │ 202504 │ purchase      │  10 │
7. │ 202505 │ auth          │  19 │
8. │ 202505 │ logout        │  20 │
9. │ 202505 │ purchase      │  19 │
   └────────┴───────────────┴─────┘

9 rows in set. Elapsed: 0.005 sec.
```

Описанные действия можно рассматривать как пример замены данных в отдельной партиции путём её временного отключения от основной таблицы.

### TTL для автоматического удаления старых партиций

Настроим время жизни данных, чтобы хранились только записи за текущий и предыдущий месяц (работа выполнялась в *июне 2025г.*).

```sql
ALTER TABLE user_activity
    (MODIFY TTL toStartOfMonth(activity_date) + interval 2 months)

0 rows in set. Elapsed: 0.040 sec.
```

Проверим, что изменение TTL было сразу применено:

```sql
SELECT
    `table`,
    mutation_id,
    command,
    is_done
FROM system.mutations
WHERE `table` = 'user_activity'
FORMAT vertical

Row 1:
──────
table:       user_activity
mutation_id: mutation_4.txt
command:     (UPDATE activity_type = 'auth' WHERE activity_type = 'login')
is_done:     1

Row 2:
──────
table:       user_activity
mutation_id: mutation_7.txt
command:     (MATERIALIZE TTL)
is_done:     1

2 rows in set. Elapsed: 0.005 sec.
```

Посмотрим на содержимое таблицы и убедимся что данные за март и апрель действительно были удалены по условию TTL:

```sql
SELECT
    mon,
    activity_type,
    count() AS cnt
FROM user_activity
GROUP BY
    toYYYYMM(activity_date) AS mon,
    activity_type
ORDER BY
    mon ASC,
    activity_type ASC

   ┌────mon─┬─activity_type─┬─cnt─┐
1. │ 202505 │ auth          │  19 │
2. │ 202505 │ logout        │  20 │
3. │ 202505 │ purchase      │  19 │
   └────────┴───────────────┴─────┘

3 rows in set. Elapsed: 0.012 sec.
```

Наконец, проверим состояние партиций таблицы *user_activity* и также убедимся, что соответствующие партиции были удалены:

```sql
SELECT
    `table`,
    partition,
    name,
    rows,
    active
FROM system.parts
WHERE (`table` = 'user_activity') AND active

   ┌─table─────────┬─partition─┬─name───────────┬─rows─┬─active─┐
1. │ user_activity │ 202505    │ 202505_3_3_0_7 │   58 │      1 │
   └───────────────┴───────────┴────────────────┴──────┴────────┘

1 row in set. Elapsed: 0.003 sec.
```
